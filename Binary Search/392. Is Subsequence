/***
Given a string s and a string t, check if s is subsequence of t.

You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) 
string, and s is a short string (<=100).

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the 
characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while 
"aec" is not).

Example 1:
s = "abc", t = "ahbgdc"

Return true.

Example 2:
s = "axc", t = "ahbgdc"

Return false.

Follow up:
If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its 
subsequence. In this scenario, how would you change your code?
***/
#1 Linear Two Pointers Solution
public class Solution {
    public boolean isSubsequence(String s, String t) {
        if (s.length() == 0) return true;
        int indexS = 0, indexT = 0;
        while (indexT < t.length()) {
            if (t.charAt(indexT) == s.charAt(indexS)) {
                indexS++;
                if (indexS == s.length()) return true;
            }
            indexT++;
        }
        return false;
    }
}
#2 Follow-Up: t(very huge) only got processed once possible?
原理： The prev variable is an index where previous character was picked from the sequence. And for the next character to be 
      picked, you have to select it only after this index is the string ‘T’.
      For instance, if S = "abcd" and T = "abdced".
      The index list mapping looks like,
      a -> 0
      b -> 1
      c -> 3
      d -> 2,5
      e -> 4
      After you pick a, and b, c will be picked, and index is 3. Now if you have to pick d, you can’t pick index 2 because c 
      was picked at 3, so you have to binary search for index which comes after 3. So it returns 5.
