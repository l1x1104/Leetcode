
Java Search Algos : http://www.java2novice.com/java-search-algorithms/

35. Search Insert Position
    æ ‡å‡†æ¨¡æ¿
    public int searchInsert(int[] nums, int target) {
        int start = 0, end = nums.length-1;
        
        while (start <= end) {
            int mid = start + (end-start) / 2;
            if(nums[mid] < target) {
                start = mid + 1;
            } else if(nums[mid] > target) {
                end = mid - 1;
            } else 
                return mid;
        }
        
        return start;
    }
    
    whileå¾ªç¯æ¡ä»¶æ”¹ä¸€ä¸‹:
    
    public int searchInsert(int[] nums, int target) {
        int s = 0, e = nums.length-1;
        while(s < e){
            int m = s + (e - s) / 2;
            if(nums[m] < target) {
                s = m + 1;
            } else if(nums[m] > target) {
                e = m;
            } else return m;
        }
  
        return target > nums[s] ? s + 1: s;
    }
    
    å¼„æ‡‚æ¯ä¸€å¥è¯èƒŒåæ·±åˆ»çš„å«ä¹‰:
    
    1. start < end VS start <= end åŒºåˆ«
       å¯¹æ•°ç»„[1, 3, 5, 6] target = ...
       start < endåœä¸‹æ¥æ¡ä»¶æ˜¯ start == end. æ¯”å¦‚target = 6,æœ€ååœä¸‹æ¥çš„indexä¸€å®šæ˜¯startç­‰äºendç­‰äº3. æ¢è€Œè¨€ä¹‹ï¼Œå¦‚æœtargetè¶…è¿‡æ•°ç»„é•¿åº¦ï¼Œ
       æ¯”å¦‚target == 6ï¼Œ startæœ€å¤§åªèƒ½åˆ°endåˆå§‹å€¼ï¼Œå³index 3. æ•…æ— æ³•å¾—åˆ°æ­£ç¡®ç»“æœ4.
       ç»¼ä¸Šï¼Œç¨‹åºæ”¹æˆå¦‚ä¸‹å°±èƒ½è·‘å¯¹
       int s = 0, e = nums.length;  // å»æ‰å‡ä¸€
       while (s < e) {
            int m = s + (e - s) / 2;
            if(nums[m] < target) {
                s = m + 1;
            } else if(nums[m] > target) {
                e = m;
            } else return m;
        }
      
      å¦‚æœæ”¹æˆstart <= endï¼Œç»æµ‹è¯•ï¼Œcase [1, 3, 5, 6] target = 2 => TLE
      åŸå› ? 
      left = 0,  right = 3, nums[mid] = 3 > target, æ‰€ä»¥ right = 1
      left = 0,  right = 1, nums[mid] = 1 < target, æ‰€ä»¥  left = 1
      é‚£ä¹ˆé—®é¢˜æ¥äº†, ä»è¿™ä¸€æ­¥ä»¥å, left = right = 1, nums[1] > target = 3, right = 1,
      æ­»å¾ªç¯...
      
      æˆ–è€…è¯´, è¿™ç§å†™æ³•å› ä¸ºç»ˆæ­¢æ¡ä»¶æ˜¯left > right, æ‰€ä»¥leftèµ·å§‹å€¼æ˜¯0ï¼Œæœ€å°åªèƒ½æ˜¯1, å¦‚æœtarget = 0, å®ƒè¦insertçš„ç‚¹æ˜¯index = 0, ä¹Ÿä¼šæ­»å¾ªç¯.
      è¿™ç§å†™æ³•å¾ˆå®¹æ˜“é€ æˆleft == rightçš„æ—¶å€™ï¼Œå› ä¸ºä½ è¡¨è¾¾å¼é‡Œright = midï¼Œæ‰€ä»¥target = 2 æ­£å¥½å°äºnums[1] = 3ï¼Œè¿™æ ·rightè¿˜æ˜¯è¢«èµ‹å€¼ä¸º1ï¼Œé€ æˆ
      æ­»å¾ªç¯. æ”¹è¿›åŠæ³•å°±æ˜¯å†™æˆ left = mid - 1. è§æœ€å‰æ–¹æ ‡å‡†æ¨¡æ¿.
  
      ------------ åˆ†å‰²çº¿ -------------
      å¾…æˆ‘åœ¨è‰ç¨¿ç‰ˆä¸Šç”»äº†4ç§targetå€¼æƒ…å†µä¸‹å·¦å³æŒ‡é’ˆæ€ä¹ˆèµ°ä¹‹åï¼Œå‘ç°æœ¬è´¨ä¸ä¼š while(condition) æ­»å¾ªç¯æ¡ä»¶æ˜¯conditionè¦èƒ½è·³å‡ºæ¥. 
      æ¯”å¦‚ start <= endï¼Œå¦‚æœæŸç§æƒ…å†µä¸‹å·¦å³æŒ‡é’ˆæ­£å¥½é‡åˆ(start == end)ï¼Œä¸ç®¡æ˜¯left = mid + 1æˆ–æ˜¯right = midï¼Œéƒ½æ— æ³•è®©é‡åˆçš„æŒ‡é’ˆ é”™å¼€ï¼Œ
      å°±æ˜¯æ­»å¾ªç¯.
      
      
      ç„¶åæ¥ä¸‹å»è€ƒè™‘å·¦å³æŒ‡é’ˆæå€¼å°±å¯ä»¥äº†.
      æ¯”å¦‚ä½ conditionæ˜¯left < right, ç»ˆæ­¢æ—¶åˆ»left = right, è€Œrightèµ·å§‹å€¼å°±æ˜¯length - 1ï¼Œå¦‚æœè¦è¿”å›ä¸€ä¸ªLengthå€¼ï¼Œæ€ä¹ˆå¯èƒ½ï¼Ÿ
      å†æ¯”å¦‚conditionæ˜¯left <= right,ç»ˆæ­¢æ—¶åˆ»left > rightï¼Œå¦‚æœä½ è¦è¿”å›çš„ç‚¹æ˜¯ç¬¬ä¸€ä¸ªæ€ä¹ˆåŠï¼Ÿ è®¡ç®—midè¡¨è¾¾å¼é å·¦ï¼Œæ‰€ä»¥å¾ˆå¯èƒ½å‡ºç° left == right
      (right = mid;)çš„æƒ…å†µï¼Œç”±äºconditionæ˜¯left <= rightï¼Œå¾ˆå®¹æ˜“æ­»å¾ªç¯ï¼Œæ‰€ä»¥åŠ ä¸Šright = mid - 1;è¿™æ ·é€ æˆå·¦æŒ‡é’ˆåœ¨å³æŒ‡é’ˆå³è¾¹(left > right)ç¨‹
      åºè·³å‡ºï¼Œå°±èƒ½å¾—åˆ°Index = 0çš„æ­£ç¡®ç»“æœå•¦.
      
      ----------- ç»“æŸçº¿ --------------
  
      arrayè¦ sortedï¼Œå› ä¸ºä½ åœ¨if(O(1))çš„æ—¶é—´å¤æ‚åº¦é‡Œè¦å†³å®šå¾€å·¦è¿˜æ˜¯å¾€å³ï¼ŒYou cut the time complexity to half in this way.
      
      
      ----------- å¼€å§‹çº¿ --------------
      
      34. Search for a Range
        Â· æˆ‘å…ˆé€‰æ‹©äº†left < rightè¿™ä¸ªä½œä¸ºbsæ¨¡æ¿
        
      class Solution {
        public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0 || nums == null || (nums.length == 1 && nums[0] != target)) return new int[]{-1, -1};
        
        int left = 0, right = nums.length, mid;
        int[] res = new int[2];
        
        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        if (left == nums.length || (left == 0 && nums[left] != target)) {
            return new int[]{-1, -1};
        } else {
            res[0] = left;
        }
        
        left = 0; 
        right = nums.length; 
        target += 1;
        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        } 
        
        if (left <= res[0]) return new int[]{-1, -1}; 
        res[1] = left - 1;
        
        return res;   
    }
 }
   
   
   .
   .
   .
   è¿™æ˜¯æˆ‘ç‹¬ç«‹å†™å‡ºæ¥çš„ç¬¬ä¸€ç‰ˆï¼Œå¥‡ä¸‘æ— æ¯”ï¼Œä½†è‚¯å®šæ˜¯é¢è¯•èƒ½é€šè¿‡. å½“ç€é¢è¯•å®˜çš„é¢ï¼Œè¿›ä¸€æ­¥ä¼˜åŒ–.
   
   é¦–å½“å…¶å†²ï¼ŒbinarySearchå†™æˆä¸€ä¸ªå‡½æ•°ï¼ŒåŒä¸€ä¸ªæ±‚Indexçš„å‡½æ•°ä¸ºä»€ä¹ˆè¦å†™ä¸¤æ¬¡. (è¿™ä¸ªï¼Œä½ åœ¨ä¸‹ç¬”ä¹‹å‰è¦èƒ½æƒ³å¥½å…ˆ)
    private int binarySearch(int target, int[] nums) {
        int left = 0, right = nums.length, mid;
        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left; 
    }
   leftæœ‰ä¸¤ç§å¯èƒ½ï¼š1) left == 0  2) left == nums.length
                 2 è‚¯å®šæ˜¯æ²¡æ‰¾åˆ°çš„ï¼Œä½†1 æœ‰å¯èƒ½æ˜¯ä½ è¦æ‰¾çš„æ•°ï¼Œä¹Ÿæœ‰å¯èƒ½index = 0è¿™ä¸ªç‚¹æ’å…¥. å¯ä»¥è¡¨è¾¾æˆ target < nums[left](targetæ¯”æ‰€æœ‰æ•°éƒ½å°)
                  æˆ–è€…ç›´æ¥ left == 0 && target != nums[left], è¿›ä¸€æ­¥å†™æˆ nums[0] > target
                  
                  
   â€» è¿™é“é¢˜è¿˜æœ‰ä¸€ä¸ªç‰¹åˆ«è€ƒç©¶çš„åœ°æ–¹: åŸå…ˆifè¯­å¥æœ‰ä¸€ä¸ªç­‰äºçš„æƒ…å†µï¼Œè¿™é‡Œç›´æ¥break? æ³¨æ„ï¼Œä¸è¡ŒğŸš«ï¼ ä½ è¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªï¼Œç¬¬ä¸€ä¸ªï¼Œç¬¬ä¸€ä¸ªï¼Œ[1,2,2,3]ä½ è¦è¿”å›index
     ç­‰äº1è€Œä¸æ˜¯2, æ‰€ä»¥å³ä½¿ç­‰äºï¼Œæˆ‘ä»¬ä¹ŸæŠŠright = mid, æ‰€ä»¥å³ä½¿æ•°ç»„æœ‰duplicate, è¿™æ ·å†™æˆ‘ä»¬ä¹Ÿèƒ½ä¿è¯æ‰¾åˆ°çš„æ˜¯ç¬¬ä¸€ä¸ªinsert point.
                  
      
    è¿›ä¸€æ­¥è€ƒè™‘ å¦‚æœnumsåªæœ‰ä¸€ä¸ªæ•°ï¼Œä¸”numsç­‰äºæˆ–è€…ä¸ç­‰äºtargetçš„æƒ…å†µ. 

    æœ€åï¼Œ æ³¨æ„LeftBound ä¸èƒ½ç­‰äº rightBound
    
    
    class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0 || nums == null) return new int[]{-1, -1};
        int[] res = new int[2];
        
        // left bound;
        int leftBound = binarySearch(target, nums);  
        if (leftBound == nums.length || nums[0] > target) {
            return new int[]{-1, -1};
        } else {
            res[0] = leftBound;
        }
        
        // right bound;
        int rightBound = binarySearch(target + 1, nums); 
        if (rightBound == res[0]) {
            return new int[]{-1, -1}; 
        }
        res[1] = rightBound - 1;
        
        return res;   
    }
    
    private int binarySearch(int target, int[] nums) {
        int left = 0, right = nums.length, mid;
        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left; // leftæœ‰ä¸¤ç§å¯èƒ½
    }
}
