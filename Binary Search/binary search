
Java Search Algos : http://www.java2novice.com/java-search-algorithms/

35. Search Insert Position
    标准模板
    public int searchInsert(int[] nums, int target) {
        int start = 0, end = nums.length-1;
        
        while (start <= end) {
            int mid = start + (end-start) / 2;
            if(nums[mid] < target) {
                start = mid + 1;
            } else if(nums[mid] > target) {
                end = mid - 1;
            } else 
                return mid;
        }
        
        return start;
    }
    
    while循环条件改一下:
    
    public int searchInsert(int[] nums, int target) {
        int s = 0, e = nums.length-1;
        while(s < e){
            int m = s + (e - s) / 2;
            if(nums[m] < target) {
                s = m + 1;
            } else if(nums[m] > target) {
                e = m;
            } else return m;
        }
  
        return target > nums[s] ? s + 1: s;
    }
    
    弄懂每一句话背后深刻的含义:
    
    1. start < end VS start <= end 区别
       对数组[1, 3, 5, 6] target = ...
       start < end停下来条件是 start == end. 比如target = 6,最后停下来的index一定是start等于end等于3. 换而言之，如果target超过数组长度，
       比如target == 6， start最大只能到end初始值，即index 3. 故无法得到正确结果4.
       综上，程序改成如下就能跑对
       int s = 0, e = nums.length;  // 去掉减一
       while (s < e) {
            int m = s + (e - s) / 2;
            if(nums[m] < target) {
                s = m + 1;
            } else if(nums[m] > target) {
                e = m;
            } else return m;
        }
      
      如果改成start <= end，经测试，case [1, 3, 5, 6] target = 2 => TLE
      原因? 
      left = 0,  right = 3, nums[mid] = 3 > target, 所以 right = 1
      left = 0,  right = 1, nums[mid] = 1 < target, 所以  left = 1
      那么问题来了, 从这一步以后, left = right = 1, nums[1] > target = 3, right = 1,
      死循环...
      
      或者说, 这种写法因为终止条件是left > right, 所以left起始值是0，最小只能是1, 如果target = 0, 它要insert的点是index = 0, 也会死循环.
      这种写法很容易造成left == right的时候，因为你表达式里right = mid，所以target = 2 正好小于nums[1] = 3，这样right还是被赋值为1，造成
      死循环. 改进办法就是写成 left = mid - 1. 见最前方标准模板.
  
      
      
  
