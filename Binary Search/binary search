
Java Search Algos : http://www.java2novice.com/java-search-algorithms/

35. Search Insert Position
    标准模板
    public int searchInsert(int[] nums, int target) {
        int start = 0, end = nums.length-1;
        
        while (start <= end) {
            int mid = start + (end-start) / 2;
            if(nums[mid] < target) {
                start = mid + 1;
            } else if(nums[mid] > target) {
                end = mid - 1;
            } else 
                return mid;
        }
        
        return start;
    }
    
    while循环条件改一下:
    
    public int searchInsert(int[] nums, int target) {
        int s = 0, e = nums.length-1;
        while(s < e){
            int m = s + (e - s) / 2;
            if(nums[m] < target) {
                s = m + 1;
            } else if(nums[m] > target) {
                e = m;
            } else return m;
        }
  
        return target > nums[s] ? s + 1: s;
    }
    
    弄懂每一句话背后深刻的含义:
    
    1. start < end VS start <= end 区别
       对数组[1, 3, 5, 6] target = ...
       start < end停下来条件是 start == end. 比如target = 6,最后停下来的index一定是start等于end等于3. 换而言之，如果target超过数组长度，
       比如target == 6， start最大只能到end初始值，即index 3. 故无法得到正确结果4.
       综上，程序改成如下就能跑对
       int s = 0, e = nums.length;  // 去掉减一
       while (s < e) {
            int m = s + (e - s) / 2;
            if(nums[m] < target) {
                s = m + 1;
            } else if(nums[m] > target) {
                e = m;
            } else return m;
        }
      
      如果改成start <= end，经测试，case [1, 3, 5, 6] target = 2 => TLE
      原因? 
      left = 0,  right = 3, nums[mid] = 3 > target, 所以 right = 1
      left = 0,  right = 1, nums[mid] = 1 < target, 所以  left = 1
      那么问题来了, 从这一步以后, left = right = 1, nums[1] > target = 3, right = 1,
      死循环...
      
      或者说, 这种写法因为终止条件是left > right, 所以left起始值是0，最小只能是1, 如果target = 0, 它要insert的点是index = 0, 也会死循环.
      这种写法很容易造成left == right的时候，因为你表达式里right = mid，所以target = 2 正好小于nums[1] = 3，这样right还是被赋值为1，造成
      死循环. 改进办法就是写成 left = mid - 1. 见最前方标准模板.
  
      ------------ 分割线 -------------
      待我在草稿版上画了4种target值情况下左右指针怎么走之后，发现本质不会 while(condition) 死循环条件是condition要能跳出来. 
      比如 start <= end，如果某种情况下左右指针正好重合(start == end)，不管是left = mid + 1或是right = mid，都无法让重合的指针 错开，
      就是死循环.
      
      
      然后接下去考虑左右指针极值就可以了.
      比如你condition是left < right, 终止时刻left = right, 而right起始值就是length - 1，如果要返回一个Length值，怎么可能？
      再比如condition是left <= right,终止时刻left > right，如果你要返回的点是第一个怎么办？ 计算mid表达式靠左，所以很可能出现 left == right
      (right = mid;)的情况，由于condition是left <= right，很容易死循环，所以加上right = mid - 1;这样造成左指针在右指针右边(left > right)程
      序跳出，就能得到Index = 0的正确结果啦.
      
      ----------- 结束线 --------------
  
      array要 sorted，因为你在if(O(1))的时间复杂度里要决定往左还是往右，You cut the time complexity to half in this way.
      
      
      ----------- 开始线 --------------
      
      34. Search for a Range
        · 我先选择了left < right这个作为bs模板
        
      class Solution {
        public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0 || nums == null || (nums.length == 1 && nums[0] != target)) return new int[]{-1, -1};
        
        int left = 0, right = nums.length, mid;
        int[] res = new int[2];
        
        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        if (left == nums.length || (left == 0 && nums[left] != target)) {
            return new int[]{-1, -1};
        } else {
            res[0] = left;
        }
        
        left = 0; 
        right = nums.length; 
        target += 1;
        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        } 
        
        if (left <= res[0]) return new int[]{-1, -1}; 
        res[1] = left - 1;
        
        return res;   
    }
 }
   
   
   .
   .
   .
   这是我独立写出来的第一版，奇丑无比，但肯定是面试能通过. 当着面试官的面，进一步优化.
   
   
      
      
