
Java Search Algos : http://www.java2novice.com/java-search-algorithms/

35. Search Insert Position
    标准模板
    public int searchInsert(int[] nums, int target) {
        int start = 0, end = nums.length-1;
        
        while (start <= end) {
            int mid = start + (end-start) / 2;
            if(nums[mid] < target) {
                start = mid + 1;
            } else if(nums[mid] > target) {
                end = mid - 1;
            } else 
                return mid;
        }
        
        return start;
    }
    
    while循环条件改一下:
    
    public int searchInsert(int[] nums, int target) {
        int s = 0, e = nums.length-1;
        while(s < e){
            int m = s + (e - s) / 2;
            if(nums[m] < target) {
                s = m + 1;
            } else if(nums[m] > target) {
                e = m;
            } else return m;
        }
  
        return target > nums[s] ? s + 1: s;
    }
    
    弄懂每一句话背后深刻的含义:
    
    1. start < end VS start <= end 区别
       对数组[1, 3, 5, 6] target = ...
       start < end停下来条件是 start == end. 比如target = 6,最后停下来的index一定是start等于end等于3. 换而言之，如果target超过数组长度，
       比如target == 6， start最大只能到end初始值，即index 3. 故无法得到正确结果4.
       综上，程序改成如下就能跑对
       int s = 0, e = nums.length;  // 去掉减一
       while (s < e) {
            int m = s + (e - s) / 2;
            if(nums[m] < target) {
                s = m + 1;
            } else if(nums[m] > target) {
                e = m;
            } else return m;
        }
      
      如果改成start <= end，经测试，case [1, 3, 5, 6] target = 2 => TLE
      原因? 
      left = 0,  right = 3, nums[mid] = 3 > target, 所以 right = 1
      left = 0,  right = 1, nums[mid] = 1 < target, 所以  left = 1
      那么问题来了, 从这一步以后, left = right = 1, nums[1] > target = 3, right = 1,
      死循环...
      
      或者说, 这种写法因为终止条件是left > right, 所以left起始值是0，最小只能是1, 如果target = 0, 它要insert的点是index = 0, 也会死循环.
      这种写法很容易造成left == right的时候，因为你表达式里right = mid，所以target = 2 正好小于nums[1] = 3，这样right还是被赋值为1，造成
      死循环. 改进办法就是写成 left = mid - 1. 见最前方标准模板.
  
      ------------ 分割线 -------------
      待我在草稿版上画了4种target值情况下左右指针怎么走之后，发现本质不会 while(condition) 死循环条件是condition要能跳出来. 
      比如 start <= end，如果某种情况下左右指针正好重合(start == end)，不管是left = mid + 1或是right = mid，都无法让重合的指针 错开，
      就是死循环.
      
      
      然后接下去考虑左右指针极值就可以了.
      比如你condition是left < right, 终止时刻left = right, 而right起始值就是length - 1，如果要返回一个Length值，怎么可能？
      再比如condition是left <= right,终止时刻left > right，如果你要返回的点是第一个怎么办？
      
      ----------- 结束线 --------------
  
