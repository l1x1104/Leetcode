续，做题小技巧 - letter combination..

2. 每层元素相同 
   比如 [2,3,6,7],
   
   每一层的元素有哪些？或者，你可以想，每一层有哪些元素可供选择 - chosen set是什么？
   
   与电话号码那题不同，就一个数组，只不过每层取舍的元素不同而已！简单！
   
   Algo Visualization:
                   stack frame level      i = 0      i = 1     i = 2     i = 3
                          1                 2          3         6         7
                          2                 3          2         2         2
                          3                 6          3         3         3
                          4                 7          6         6         6
                                                       7         7         7
                   深度等于candidate.length.
   
   1)首先考虑，
   同一个元素可以使用两次，比如[2,2,3]，所以“每一层元素组都是[2,3,6,7]”->for(i = 0;...). 初看是对的，接下去.
   
   2)然后考虑，
   题目要求unique combination, [2,2,3]和[3,2,2]就算同一种，不行. 怎么样情况下会发生? 如上图，i=1时，如果没有start的index(for(i = start))
   当前层的index传递给下一层，告诉下一层：不能直接从i=1之前的开始（从"我"!3开始找，允许重复使用).这样就避免了[3,2,2]这种答案.
   不走回头路,方法就是增加传参int start.
   
   如果[3,2,2]也算进答案集，那么就成了permutation!
   
   ----------------------------------------------- Follow-UP ---------------------------------------------------------------
   如果有重复元素怎么办?
   
   先想重复元素会带来什么问题. 比如[10, 1, 2, 7, 6, 1, 5], i = 1时，👆我们通过增加参数start保证了不走当前index之前的数，but！如果当前index之后
   数有一样的怎么办？👆之所以能用是因为start这种方式我们确保之后的数不会重复，比如[1,7]和[7,1]两个不同的1 index其实并不一样. 
   
   方法是sort当前数组，每一层循环时候跳过和start一样的元素，因为i=start时候已经做过一次！
   
   代码
   可以从当前层下手: if(i > start && arr[i] == arr[i-1]) continue;
                     (之前循环过的index不要再做一次)
   也可以从下一层着手:   if (i > 0 && !visited[i - 1] && candidates[i] == candidates[i - 1]) continue;
                      (上一层用过的元素且和当前层相等，跳过)
   
   
   (※)重点来了(※)
   必须sort! 原因？
   不sort，观察现象->找到出错的原因->想办法躲开出错原因
   Your input
   [10,1,2,7,6,1,5]
   8
   Your answer
   [[1,2,5],[1,7],[1,6,1],[2,6],[2,1,5],[7,1]]
   Expected answer
   [[1,1,6],[1,2,5],[1,7],[2,6]]
   第一个[1,2,5]，第二个[2,1,5]的1是index=5这个. 如果你sort了，[..1,1,2,5,..]当你用第一个1做完combination之后会skip再次以1打头的组合.
  
   实质是通过skip方式把数组简化成->[1,2,5,6,7,10]做combination sum I. 所以说，其实代码从当前层下手逻辑更明白.(验证：自动义把多余的1去掉，注释sort
   run code,你会发现结果是对的)
