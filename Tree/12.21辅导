第一题、 102. Binary Tree Level Order Traversal
    #1 bfs 
    #2 dfs solution
        class Solution {
            public List<List<Integer>> levelOrder(TreeNode root) {
                List<List<Integer>> res = new ArrayList<>();
                helper(root, 0, res);
                return res;
            }
            public void helper(TreeNode root, int level, List<List<Integer>> res) {
                if(root == null) return ;
                if(level == res.size()) res.add(new LinkedList<>());
                res.get(level).add(root.val);
                helper(root.left, level + 1, res);
                helper(root.right, level + 1, res);
            }
        }

第二题、 ZigZag levelOrder traversal
        class Solution {
            public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
                List<List<Integer>> res = new ArrayList<>();
                helper(root, 0, res);
                return res;
            }
            public void helper(TreeNode root, int level, List<List<Integer>> res) {
                if(root == null) return ;
                if(level == res.size()) res.add(new LinkedList<>());
                if(level % 2 == 0) res.get(level).add(root.val);
                else res.get(level).add(0, root.val);
                helper(root.left, level + 1, res);
                helper(root.right, level + 1, res);
            }
        }
    
第三题、 104. Maximum Depth of Binary Tree
        class Solution {
            public int maxDepth(TreeNode root) {
                if(root == null) return 0;
                int left = maxDepth(root.left);
                int right = maxDepth(root.right);
                return 1 + Math.max(left, right);
            }
        }

第四题、 111. Minimum Depth of Binary Tree
     #1 class Solution {
            public int minDepth(TreeNode root) {
                if(root == null) return 0;
                int left = minDepth(root.left);
                int right = minDepth(root.right);
                return (left == 0 || right == 0) ? left + right + 1 : 1 + Math.min(left, right) + ;
            }
        }
        或者，
     #2 class Solution {
            public int minDepth(TreeNode root) {
                if(root == null) return 0;
                if(root.left == null && root.right == null) return 1;
                else if(root.left == null || root.right == null) {
                    if(root.left != null) return 1 + minDepth(root.left);
                    if(root.right != null) return 1 + minDepth(root.right);
                }
                return 1 + Math.min(minDepth(root.left), minDepth(root.right));
            }
        }
        
第五题、 105 Construct Binary Tree from Preorder and Inorder Traversal
