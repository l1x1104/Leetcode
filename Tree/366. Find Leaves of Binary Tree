/*
 Date:       Dec 25, 2017
 Update:     Dec 25, 2017
 Problem:    Find Leaves of Binary Tree
 Difficulty: Medium
 Notes:
 Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is
 empty.
 For example:
 Given binary tree {1,#,2,3},
          1
         / \
        2   3
       / \     
      4   5    
 Returns [4, 5, 3], [2], [1].
 Note: Recursive solution is trivial, could you do it iteratively?
 Solution: 1. Recursive solution.      Time: O(2n), Space: O(n).
 */
 class Solution {
    public List<List<Integer>> findLeaves(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        Map<TreeNode, Integer> map = new HashMap<>();
        int num = dfs(root, map);
        for(int i = 0; i < num; i++) {
            res.add(new ArrayList<>());
        }
        helper(root, res, map);
        return res;
    }
    private int dfs(TreeNode root, Map<TreeNode, Integer> map) {
        if(root == null) return 0;
        int left = dfs(root.left, map);
        int right = dfs(root.right, map);
        map.put(root, Math.max(left, right));
        return 1 + Math.max(left, right);
    }
    private void helper(TreeNode root, List<List<Integer>> res, Map<TreeNode, Integer> map) {
        if(root == null) return ;
        helper(root.left, res, map);
        helper(root.right, res, map);
        int level = map.get(root);
        List<Integer> tmp = res.get(level);
        tmp.add(root.val);
    }
  }
